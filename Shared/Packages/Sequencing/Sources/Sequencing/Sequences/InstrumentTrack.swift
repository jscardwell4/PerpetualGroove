//
//  InstrumentTrack.swift
//  PerpetualGroove
//
//  Created by Jason Cardwell on 8/14/15.
//  Copyright Â© 2015 Moondeer Studios. All rights reserved.
//
import Combine
import Common
import CoreMIDI
import Foundation
import MIDI
import MoonDev
import SoundFont
import SwiftUI

// MARK: - InstrumentTrack

/// A subclass of `Track` containing MIDI events for adding/removing MIDI nodes as well
/// as MIDI events for configuring the sound used for note events generated by those
/// MIDI nodes.
@available(iOS 14.0, *)
@available(macCatalyst 14.0, *)
@available(OSX 10.15, *)
public final class InstrumentTrack: ObservableObject, ColorCurated, Track, NodeManaging
{

  @EnvironmentObject var sequencer: Sequencer

  // MARK: Stored Properties

  public let id = UUID()

  /// The position of the track's MIDI file chunk within all track chunks for `sequence`.
  public var index: Int

  /// Container for the track's MIDI events. The events may be intended for dispatch by the
  /// track or they may have been created solely for inclusion in a MIDI file track chunk.
  public let eventManager = EventManager()

  /// The name assigned to the track. The default value for this property is the empty
  /// string. When the value of this property is changed. `didUpdate` and `didChangeName`
  /// notifications are posted for the track.
  @Published public var name: String = ""

  /// A manager for the MIDI nodes dispatched by the track.
  private(set) lazy var nodeManager = try! NodeManager(owner: self,
                                                       instrument: instrument)

  /// The MIDI event that specifies the instrument used by the track.
  private var instrumentEvent: MetaEvent!

  /// The MIDI event that specifies the program used by the track.
  private var programEvent: ChannelEvent!

  /// The instrument used by the track.
  public var instrument: Instrument

  /// The color used for this track.
  @Published public var color: CuratedColor

  /// An index of the loops that have been added to the track keyed by their identifiers.
  private var loops: [UUID: Loop] = [:]

  /// Subject for publishing pulses upon update.
  private let didUpdateSubject = PassthroughSubject<Void, Never>()

  // MARK: Computed Properties

  /// Flag indicating whether new events should be persisted. This is `true` iff the
  /// sequencer is in it's default mode and the track is the current dispatch for the
  /// MIDI node player.
  public var isRecording: Bool { nodeManager.isRecording }

  /// A name for the track suitable for display in the user interface. The value of this
  /// property is derived via the following checks:
  /// 1. If the track's name is not empty, return the track's name.
  /// 2. If the track has initialized such that the instrument is available, return
  ///    program name for the instrument's current preset.
  /// 3. Return the empty string.
  public var displayName: String
  {
    get { name.isEmpty ? instrument.preset.programName : name }
    set { name = newValue }
  }

  /// Overridden to append `InstrumentTrack` specific information.
  public var description: String
  {
    """
    instrument: \(instrument)
    color: \(color)
    """
    //    \(super.description)
  }

  // MARK: MIDIFile support

  /// Overridden to refresh the values of `instrumentEvent` and `programEvent` before
  /// invoking `super`'s implementation.
  public func validate(events container: inout EventContainer)
  {
    // Create the text for the instrument event.
    let instrumentText = "instrument:\(instrument.soundFont.url.lastPathComponent)"

    // Update `instrumentEvent` with a new meta event containging `instrumentText`.
    instrumentEvent = MetaEvent(data: .text(text: instrumentText))

    // Update `programEvent` with a new program change channel event that uses
    // the instrument's channel and program values.
    programEvent = try! ChannelEvent(kind: .programChange,
                                     channel: instrument.channel,
                                     data1: instrument.program)

  }

  /// The track's initial MIDI events. Overridden to append `instrumentEvent` and
  /// `programEvent` to the array returned by the inherited implementation.
  public var headEvents: [Event]
  {
    commonHeadEvents + [.meta(instrumentEvent), .channel(programEvent)]
  }

  // MARK: Event Manager

  /// Filters out the instrument and program events from the collection provided.
  /// This method is passed along to `eventManager.additionFilter`
  ///
  /// - Parameter events: The events to filter.
  /// - Returns: `events` with instrument and program events removed.
  private func additionFilter(events: [Event]) -> [Event]
  {
    // Create an array for accumulating events to provide the default implementation.
    var filteredEvents: [Event] = []

    // Iterate through the events.
    for event in events
    {
      // Consider the kind of event.
      switch event
      {
        case let .meta(metaEvent):
          // Check the kind of data attached to the meta event

          switch metaEvent.data
          {
            case let .text(text)
            where text.hasPrefix("instrument:"):
              // The event specifies the track's instrument.

              // Update `instrumentEvent` with `event`.
              instrumentEvent = metaEvent

            default:
              // The event should be passed through to `super`.

              // Append the event to `filteredEvents`.
              filteredEvents.append(event)
          }

        case let .channel(channelEvent)
        where channelEvent.status.kind == .programChange:
          // The event specifies the program for the instrument.

          // Update `programEvent` with `event`.
          programEvent = channelEvent

        default:
          // The event should be passed through to `super`.

          // Append the event to `filteredEvents`.
          filteredEvents.append(event)
      }
    }
    return filteredEvents
  }


  /// Returns times for MIDI node events contained by `events`.
  /// - Parameter events: The array of MIDI events.
  /// - Returns: An array of bar-beat times to register for callbacks.
  private func additionalRegistrationTimes(forAdding events: [Event]) -> [BarBeatTime]
  {
    events.filter { if case .node = $0 { return true } else { return false } }.map(\.time)
  }

  // MARK: Loop Management

  /// Adds the specified loop to the track by storing it in `loops` and adding the loop's
  /// MIDI events.
  ///
  /// - Parameter loop: The loop to add to the track.
  /// - Precondition: The loop has not already been added to the track.
  public func add(loop: Loop)
  {
    // Check that the loop has not already been added to the track.
    guard loops[loop.identifier] == nil else { return }

    logi("adding loop: \(loop)")

    // Store the loop by it's identifier.
    loops[loop.identifier] = loop

    // Add the loop's MIDI events.
    eventManager.add(events: loop)
  }

  // MARK: Initializing

  /// Updates the closures stored by `eventManager`.
  private func configureEventManager()
  {
    eventManager.additionFilter = additionFilter(events:)
    eventManager.nodeManager = nodeManager
    eventManager.additionalTimes = additionalRegistrationTimes(forAdding:)
  }

  /// Initializing with an index and an instrument. Initializes an empty track
  /// that uses the specified instrument, assigning itself as the instrument's track.
  ///
  /// - Parameters:
  ///   - index: The track's index.
  ///   - color: The color to assign to the track.
  ///   - instrument: The `Instrument` to couple with the created track.
  /// - Throws: Any error encountered creating the MIDI client or MIDI ports for the track.
  public init(index: Int, color: CuratedColor, instrument: Instrument) throws
  {
    self.index = index

    // Initialize `color` and `instrument` using the specified values.
    self.instrument = instrument
    self.color = color

    configureEventManager()

    // Initialize `instrumentEvent` using file name of the instrument's sound font.
    let instrumentText = "instrument:\(instrument.soundFont.url.lastPathComponent)"
    instrumentEvent = MetaEvent(data: .text(text: instrumentText))

    // Initialize `programEvent` with the instrument's channel and program values.
    programEvent = try! ChannelEvent(kind: .programChange,
                                     channel: instrument.channel,
                                     data1: instrument.program)
  }

  public init(index: Int,
              preset: Instrument.Preset,
              color: CuratedColor,
              name: String,
              events: [Event]) throws
  {
    self.index = index
    instrument = try Instrument(preset: preset)
    self.color = color
    configureEventManager()
    self.name = name
    eventManager.add(events: events)
  }

  /// Initializing with an index and a MIDI file chunk.
  ///
  /// - Parameters:
  ///   - index: The track's index.
  ///   - trackChunk: The `MIDIFile.TrackChunk` containing the MIDI events for
  ///                 initializing the track.
  /// - Throws: Any error encountered creating a new instrument for the track, any error
  ///           encountered creating the track's MIDI client/ports.
  /// - TODO: When using the MIDI events contained by `trackChunk` to generate the track's
  ///         instrument, a bank change event should be queried rather than assuming a
  ///         bank value of `0`.
  public init(index: Int, trackChunk: TrackChunk) throws
  {
    self.index = index

    // Look for MIDI events relating to the instrument.
    if let instrumentIndex = trackChunk.events.firstIndex(where: {
      guard case let .meta(metaEvent) = $0,
            case let .text(text) = metaEvent.data,
            text.hasPrefix("instrument:")
      else { return false }
      return true
    }),
      let programIndex = trackChunk.events.firstIndex(where: {
        guard case let .channel(channelEvent) = $0,
              channelEvent.status.kind == .programChange
        else { return false }
        return true
      }),
      case let .meta(instrument) = trackChunk.events[instrumentIndex],
      case let .channel(program) = trackChunk.events[programIndex]
    {
      self.instrument = try Instrument(instrument: instrument, program: program)
    }
    else
    {
      let soundFont = SoundFont.bundledFonts[0]

      // Get the first preset header of the first sound font.
      let header = soundFont.presetHeaders[0]

      // Create a preset for the audition instrument.
      let preset = Instrument.Preset(font: soundFont, header: header, channel: 0)
      
      instrument = try Instrument(preset: preset)
    }

    // Use `index` to assign the track's color.
    color = CuratedColor[index]

    configureEventManager()

    // Add the MIDI events provided by the chunk to the track.
    eventManager.add(events: trackChunk.events)
  }
}

// MARK: - Publishers

@available(iOS 14.0, *)
@available(macCatalyst 14.0, *)
@available(OSX 10.15, *)
extension InstrumentTrack
{
  public enum PublishedSubject
  {
    case didUpdate
  }

  public func publisher(for subject: PublishedSubject) -> AnyPublisher<Void,Never>
  {
    didUpdateSubject.eraseToAnyPublisher()
  }

}

// MARK: Hashable

@available(iOS 14.0, *)
extension InstrumentTrack: Hashable
{
  public func hash(into hasher: inout Hasher)
  {
    ObjectIdentifier(self).hash(into: &hasher)
  }

  /// Returns `true` iff `lhs` and `rhs` are the same instance.
  public static func == (lhs: InstrumentTrack, rhs: InstrumentTrack) -> Bool
  {
    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)
  }
}

// MARK: Mock

@available(iOS 14.0, *)
@available(macCatalyst 14.0, *)
@available(OSX 10.15, *)
extension InstrumentTrack: Mock
{
  public static var mock: InstrumentTrack
  {
    try! InstrumentTrack(index: 1, color: .muddyWaters, instrument: Instrument.mock)
  }

  public static func mocks(_ count: Int) -> [InstrumentTrack]
  {
    var result: [InstrumentTrack] = []
    for (index, instrument) in Instrument.mocks(count).enumerated()
    {
      result.append(try! InstrumentTrack(
        index: index,
        color: CuratedColor[index],
        instrument: instrument
      ))
    }
    logv("""
    <\(#fileID) \(#function)> [
      \(result.map(\.description).joined(separator: "\n  "))
    """)
    return result
  }
}
