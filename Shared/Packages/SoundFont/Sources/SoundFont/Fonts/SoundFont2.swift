//
//  SoundFont2.swift
//  PerpetualGroove
//
//  Created by Jason Cardwell on 10/19/15.
//  Copyright Â© 2015 Moondeer Studios. All rights reserved.
//

import Foundation
import MoonDev
import struct SwiftUI.Image

// MARK: - SoundFont2

/// A protocol specifying an interface for types wishing to serve as a sound font resource.
@available(iOS 14.0, *)
@available(OSX 10.15, *)
public protocol SoundFont2: CustomStringConvertible, Codable
{
  /// The sound font file's location.
  var url: URL { get }
  
  /// The sound font file's data.
  var data: Data { get }

  /// The presets present in the sound font file.
  @available(OSX 11.0, *)
  var presetHeaders: [PresetHeader] { get }
  
  /// Whether the sound font contains general midi percussion presets.
  var isPercussion: Bool { get }
  
  /// The fileName to display in the user interface for the sound font.
  var displayName: String { get }
  
  /// The sound font file's base fileName without the extension.
  var fileName: String { get }
  
  /// The image to display in the user interface for the sound font.
  var image: Image { get }
  
  /// Accessor for retrieving a preset via the totally ordered array of presets.
  @available(OSX 11.0, *)
  subscript(position: Int) -> PresetHeader { get }
  
  /// Accessor for retrieving a preset by its program and bank numbers.
  @available(OSX 11.0, *)
  subscript(program program: UInt8, bank bank: UInt8) -> PresetHeader? { get }

  /// Initializing with the name of a bundled file.
  init(fileName: String) throws

  /// Initialize a sound font using it's file location.
  init(url: URL) throws
}

private enum CodingKeys: String, CodingKey { case fileName }

@available(iOS 14.0, *)
@available(OSX 10.15, *)
public extension SoundFont2
{

  init(fileName: String) throws {
    guard let url = Bundle.module.url(forResource: fileName, withExtension: "sf2")
            ?? Bundle.main.url(forResource: fileName, withExtension: "sf2")
    else
    {
      throw CustomSoundFont.Error.InvalidURL
    }
    try self.init(url: url)

  }

  func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(fileName, forKey: .fileName)
  }

  init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    try self.init(fileName: try container.decode(String.self, forKey: .fileName))
  }

  /// Returns the element in `presetHeaders` located at `position`.
  ///
  /// - Parameter position: The preset's index.
  /// - Returns: The preset at `position`.
  @available(OSX 11.0, *)
  subscript(position: Int) -> PresetHeader { presetHeaders[position] }

  /// Returns the element in `presetHeaders` matching the specified values.
  ///
  /// - Parameters:
  ///   - program: The program value for the preset.
  ///   - bank: The bank value for the preset.
  /// - Returns: The matching preset or `nil`.
  @available(OSX 11.0, *)
  subscript(program program: UInt8, bank bank: UInt8) -> PresetHeader?
  {
    presetHeaders.first(where: { $0.program == program && $0.bank == bank })
  }

  /// Returns `true` iff `other.fileName` is equal to `fileName`.
  /// - Parameter other: The sound font to which equality is being compared.
  /// - Returns: `true` if the sound font instances point to the same file
  ///            and `false` otherwise.
  func isEqualTo(_ other: SoundFont2) -> Bool { fileName == other.fileName }

  /// The contents of `fileName` as raw data.
  /// - Requires: `fileName` is valid and reachable.
  var data: Data
  {
    tryOrDie(message: "Failed to retrieve data from disk.")
    {
      try Data(contentsOf: url)
    }
  }

  /// The collection of preset headers generated by parsing `data`.
  @available(OSX 11.0, *)
  var presetHeaders: [PresetHeader]
  {
    (try? File.presetHeaders(from: data)) ?? []
  }

  var description: String { "\(displayName) - \(fileName)" }
}
