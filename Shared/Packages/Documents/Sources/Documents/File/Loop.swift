//
//  Loop.swift
//  Documents
//
//  Created by Jason Cardwell on 01/06/21.
//  Copyright Â© 2021 Moondeer Studios. All rights reserved.
//
import Foundation
import MIDI
import MoonDev

@available(macCatalyst 14.0, *)
@available(iOS 14.0, *)
extension File
{
  /// A type for specifying a repeating subsequence of node events in a track.
  public struct Loop: CustomStringConvertible, Codable
  {
    /// Typealias for the midi event kind utilized by `Loop`.
    public typealias Event = MetaEvent

    /// The unique identifier for the loop within its track.
    public var identifier: UUID

    /// The number of times the subsequence of node events should be run.
    /// Setting this property to `0` indicates that the loop should repeat forever.
    public var repetitions: Int

    /// The number of ticks after the last event generated by the loop that should
    /// elapse before beginning another repetition of loop events.
    public var repeatDelay: UInt64

    /// The bar beat time at which point the loop begins generating events for
    /// its first repetition.
    public var start: BarBeatTime

    /// The bar beat time at which point the loop ends generating events for
    /// its first repetition. Setting the value of this property to a time less
    /// than or equal to `start` indicates the loop does not end.
    public var end: BarBeatTime

    /// An index of nodes belonging to the loop.
    public var nodes: [Node.Identifier: Node] = [:]

    /// Initializing from an event. The loop created will have its start and end
    /// times set to the event's time.
    ///
    /// - Parameters:
    ///   - event: To be successful the event must be a marker with text in
    ///            the form of `start(`*identifier*`):`*repetitions*`:`*repeatDelay*
    public init?(event: Event)
    {
      // Extract the identifier, repetitions, and repeat delay from the
      // text contained in the event's data.
      guard case let .marker(text) = event.data,
            let captures = (~/"^start\\(([^)]+)\\):([0-9]+):([0-9]+)$")
            .firstMatch(in: text)?.captures

      else
      {
        return nil
      }

      let capturedID = String(captures[1]?.substring ?? "")
      let capturedReps = String(captures[2]?.substring ?? "")
      let capturedDelay = String(captures[3]?.substring ?? "")

      guard let identifier = UUID(uuidString: capturedID),
            let repetitions = Int(capturedReps),
            let repeatDelay = UInt64(capturedDelay)
      else
      {
        return nil
      }

      // Intialize `identifier`, `repetitions` and `repeatDelay` using the
      // extracted values.
      self.identifier = identifier
      self.repetitions = repetitions
      self.repeatDelay = repeatDelay

      // Use the event's time to initialize `start` and `end`.
      start = event.time
      end = event.time
    }

    private enum CodingKeys: String, CodingKey
    {
      case identifier, repetitions, repeatDelay, start, end, nodes
    }

    public func encode(to encoder: Encoder) throws
    {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(identifier, forKey: .identifier)
      try container.encode(repetitions, forKey: .repetitions)
      try container.encode(repeatDelay, forKey: .repeatDelay)
      try container.encode(start, forKey: .start)
      try container.encode(end, forKey: .end)
      try container.encode(nodes, forKey: .nodes)
    }

    public init(from decoder: Decoder) throws
    {
      let container = try decoder.container(keyedBy: CodingKeys.self)
      identifier = try container.decode(UUID.self, forKey: .identifier)
      repetitions = try container.decode(Int.self, forKey: .repetitions)
      repeatDelay = try container.decode(UInt64.self, forKey: .repeatDelay)
      start = try container.decode(BarBeatTime.self, forKey: .start)
      end = try container.decode(BarBeatTime.self, forKey: .end)
      nodes = try container.decode([Node.Identifier:Node].self, forKey: .nodes)
    }

    public var description: String {
      let encoder = JSONEncoder()
      encoder.outputFormatting = .prettyPrinted
      let data = try! encoder.encode(self)
      let string = String(data: data, encoding: .utf8)!
      return string
    }
  }
}
