//
//  Document.swift
//  PerpetualGroove
//
//  Created by Jason Cardwell on 9/28/15.
//  Copyright © 2015 Moondeer Studios. All rights reserved.
//
import Combine
import MIDI
import MoonKit
import Sequencer
import UIKit

// MARK: - Document

/// A `UIDocument` subclass for presenting a document interface usable by the application.
public final class Document: UIDocument, Named
{
  /// Whether the document is backed by an iCloud file.
  public var isUbiquitous: Bool
  {
    FileManager.default.isUbiquitousItem(at: fileURL)
  }
  
  /// The size of the document's file on disk or `0` if no file exists on disk.
  public var fileSize: UInt64
  {
    (try? FileManager.default
      .attributesOfItem(atPath: fileURL.path)[FileAttributeKey.size]) as? UInt64 ?? 0
  }
  
  /// The date the document's file was created or `nil`.
  public var fileCreationDate: Date?
  {
    (try? FileManager.default
      .attributesOfItem(atPath: fileURL.path)[FileAttributeKey.creationDate]) as? Date
  }
  
  /// Whether the source for the document is a midi file or a groove file.
  public var sourceType: SourceType? { SourceType(fileType) }
  
  /// Identical to `localizedName` unless `localizedName.isEmpty`,
  /// in which case 'unnamed` is used.
  public var name: String { localizedName.isEmpty ? "unnamed" : localizedName }
  
  /// The location as determined by the ubiquity of the item at `fileURL`.
  public var storageLocation: DocumentManager.StorageLocation
  {
    DocumentManager.StorageLocation(url: fileURL)
  }
  
  private var sequenceSubscription: Cancellable?
  
  /// The sequence constituting the actual content for the document.
  public private(set) var sequence: Sequencer.Sequence?
  {
    didSet
    {
      guard oldValue !== sequence else { return }
      if let sequence = sequence
      {
        sequenceSubscription = NotificationCenter.default
          .publisher(for: Notification.Name(rawValue: "didUpdate"), object: sequence)
          .sink
          {
            [weak self] _ in self?.updateChangeCount(.done)
          }
      }
    }
  }
  
  /// Flag indicating whether current save operation is creating or overwriting the
  /// document file.
  private var isCreating = false
  
  /// Derived property for obtaining current bookmark data for the document.
  public var bookmarkData: Data
  {
    guard let data = try? fileURL.bookmarkData(options: .suitableForBookmarkFile)
    else
    {
      fatalError("Failed to generate bookmark for `fileURL`.")
    }
    
    return data
  }
  
  /// Overridden to utilize `Manager.operationQueue`.
  override public var presentedItemOperationQueue: OperationQueue
  {
    documentManager.operationQueue
  }
  
  private var stateSubscription: Cancellable?
  
  /// Overridden to register `receptionist` for the document's state change notifications.
  override public init(fileURL url: URL)
  {
    super.init(fileURL: url)
    
    stateSubscription = NotificationCenter.default
      .publisher(for: .documentDidChangeState, object: self)
      .sink
      {
        _ in
        guard self.documentState ∋ .inConflict,
              let versions = NSFileVersion
                .unresolvedConflictVersionsOfItem(at: self.fileURL)
        else
        {
          return
        }
        logw("Conflicting versions detected: \(versions)")
      }
  }
  
  /// Initializes `sequence` using `contents`.
  ///
  /// - throws: Error.invalidContent when `!contents is Data`.
  /// - throws: Error.invalidContentType when `SourceType(typeName) == nil`.
  override public func load(fromContents contents: Any, ofType typeName: String?) throws
  {
    guard let data = contents as? Data else { throw Error.invalidContent }
    guard let type = SourceType(typeName) else { throw Error.invalidContentType }
    
    guard !data.isEmpty else { sequence = Sequencer.Sequence(); return }
    
    switch type
    {
      case .midi:
        sequence = Sequencer.Sequence(file: try MIDI.File(data: data))
        
      case .groove:
        guard let file = Documents.File(data: data) else { throw Error.invalidContent }
        sequence = Sequencer.Sequence(file: file)
    }
  }
  
  /// Returns the data generated by `sequence` as encoded by the determined source type.
  /// If `isCreating == true`, then a new empty sequence is assigned to `sequence`
  /// before encoding.
  ///
  /// - throws: Error.missingSequence when `isCreating == false && sequence == nil`.
  /// - throws: Error.invalidContentType when `SourceType(typeName) == nil`.
  override public func contents(forType typeName: String) throws -> Any
  {
    if sequence == nil, isCreating
    {
      sequence = Sequencer.Sequence()
      isCreating = false
    }
    
    guard let sequence = sequence else { throw Error.missingSequence }
    guard let type = SourceType(typeName) else { throw Error.invalidContentType }
    
    let file: DataConvertible
    switch type
    {
      case .midi: file = MIDI.File(sequence: sequence)
      case .groove: file = Documents.File(sequence: sequence, source: fileURL)
    }
    
    logi("file contents:\n\(String(describing: file))")
    
    return file.data
  }
  
  /// Overridden to log the error before `super` handles it.
  override public func handleError(_ error: Swift.Error, userInteractionPermitted: Bool)
  {
    loge("\(error as NSObject)")
    super.handleError(error, userInteractionPermitted: userInteractionPermitted)
  }
  
  /// Attempts to coordinate the renaming of the document to `newName`.
  public func rename(to newName: String)
  {
    documentManager.queue.async
    {
      [weak self] in
      
      guard let weakself = self else { return }
      
      guard newName != weakself.localizedName else { return }
      
      let directoryURL = weakself.fileURL.deletingLastPathComponent()
      let oldName = weakself.localizedName
      let oldURL = weakself.fileURL
      let newURL = directoryURL + "\(newName).groove"
      
      logi("renaming document '\(oldName)' ⟹ '\(newName)'")
      
      let fileCoordinator = NSFileCoordinator(filePresenter: nil)
      var error: NSError?
      fileCoordinator.coordinate(writingItemAt: oldURL,
                                 options: .forMoving,
                                 writingItemAt: newURL,
                                 options: .forReplacing,
                                 error: &error)
      {
        oldURL, newURL in
        
        fileCoordinator.item(at: oldURL, willMoveTo: newURL)
        do
        {
          try FileManager.default.moveItem(at: oldURL, to: newURL)
          fileCoordinator.item(at: oldURL, didMoveTo: newURL)
        }
        catch
        {
          loge("\(error as NSObject)")
        }
      }
      
      if let error = error { loge("\(error as NSObject)") }
    }
  }
  
  /// Overridden to capture whether the document is being created or overwritten.
  override public func save(to url: URL,
                            for saveOperation: UIDocument.SaveOperation,
                            completionHandler: ((Bool) -> Void)?)
  {
    isCreating = saveOperation == .forCreating
    logi("(\(self.isCreating ? "saving" : "overwriting"))  '\(url.path)'")
    super.save(to: url, for: saveOperation, completionHandler: completionHandler)
  }
  
  /// Overridden to post notification of the document's new name.
  override public func presentedItemDidMove(to newURL: URL)
  {
    super.presentedItemDidMove(to: newURL)
    
    guard let newName = newURL.pathBaseName
    else
    {
      fatalError("Failed to get base name from new url")
    }
    postNotification(name: .documentDidRenameDocument,
                     object: self,
                     userInfo: ["newName": newName])
  }
}

public extension Document
{
  /// Enumeration for specifying one of the supported document file types.
  enum SourceType: String
  {
    case midi, groove
    
    public init?(_ string: String?)
    {
      switch string?.lowercased()
      {
        case "midi",
             "mid",
             "public.midi-audio":
          self = .midi
          
        case "groove",
             "com.moondeerstudios.groove-document":
          self = .groove
          
        default:
          return nil
      }
    }
  }
}

// MARK: Document.Error

public extension Document
{
  /// Enumeration of possible errors thrown by an instance of `Document`.
  enum Error: String, Swift.Error
  {
    case invalidContentType
    case invalidContent
    case missingSequence
  }
}

// MARK: NotificationDispatching

extension Document: NotificationDispatching
{
  public static let didRenameDocumentNotification = Notification.Name("didRenameDocument")
  public static let didChangeStateNotification = UIDocument.stateChangedNotification
}

public extension Notification.Name
{
  static let documentDidRenameDocument = Document.didRenameDocumentNotification
  static let documentDidChangeState = Document.didChangeStateNotification
}

public extension Notification
{
  /// The new file name of a renamed `Document` instance or `nil`.
  var newDocumentName: String? { userInfo?["newName"] as? String }
}
